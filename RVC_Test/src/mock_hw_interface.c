/* AUTOGENERATED FILE. DO NOT EDIT. */
#include <string.h>
#include <stdlib.h>
#include <setjmp.h>
#include "cmock.h"
#include "mock_hw_interface.h"

static const char* CMockString_cleaner = "cleaner";
static const char* CMockString_cleaner_power_up = "cleaner_power_up";
static const char* CMockString_command = "command";
static const char* CMockString_dust_sensor_status = "dust_sensor_status";
static const char* CMockString_front_sensor_status = "front_sensor_status";
static const char* CMockString_left_sensor_status = "left_sensor_status";
static const char* CMockString_move_backward = "move_backward";
static const char* CMockString_move_forward = "move_forward";
static const char* CMockString_right_sensor_status = "right_sensor_status";
static const char* CMockString_status = "status";
static const char* CMockString_turn_left = "turn_left";
static const char* CMockString_turn_right = "turn_right";

typedef struct _CMOCK_front_sensor_status_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int ReturnVal;

} CMOCK_front_sensor_status_CALL_INSTANCE;

typedef struct _CMOCK_left_sensor_status_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int ReturnVal;

} CMOCK_left_sensor_status_CALL_INSTANCE;

typedef struct _CMOCK_right_sensor_status_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int ReturnVal;

} CMOCK_right_sensor_status_CALL_INSTANCE;

typedef struct _CMOCK_dust_sensor_status_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int ReturnVal;

} CMOCK_dust_sensor_status_CALL_INSTANCE;

typedef struct _CMOCK_move_forward_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  MotorStatus Expected_status;

} CMOCK_move_forward_CALL_INSTANCE;

typedef struct _CMOCK_move_backward_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  MotorStatus Expected_status;

} CMOCK_move_backward_CALL_INSTANCE;

typedef struct _CMOCK_turn_left_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;

} CMOCK_turn_left_CALL_INSTANCE;

typedef struct _CMOCK_turn_right_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;

} CMOCK_turn_right_CALL_INSTANCE;

typedef struct _CMOCK_cleaner_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  CleanerCommand Expected_command;

} CMOCK_cleaner_CALL_INSTANCE;

typedef struct _CMOCK_cleaner_power_up_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;

} CMOCK_cleaner_power_up_CALL_INSTANCE;

static struct mock_hw_interfaceInstance
{
  CMOCK_MEM_INDEX_TYPE front_sensor_status_CallInstance;
  CMOCK_MEM_INDEX_TYPE left_sensor_status_CallInstance;
  CMOCK_MEM_INDEX_TYPE right_sensor_status_CallInstance;
  CMOCK_MEM_INDEX_TYPE dust_sensor_status_CallInstance;
  CMOCK_MEM_INDEX_TYPE move_forward_CallInstance;
  CMOCK_MEM_INDEX_TYPE move_backward_CallInstance;
  CMOCK_MEM_INDEX_TYPE turn_left_CallInstance;
  CMOCK_MEM_INDEX_TYPE turn_right_CallInstance;
  CMOCK_MEM_INDEX_TYPE cleaner_CallInstance;
  CMOCK_MEM_INDEX_TYPE cleaner_power_up_CallInstance;
} Mock;

extern jmp_buf AbortFrame;

void mock_hw_interface_Verify(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_MEM_INDEX_TYPE call_instance;
  call_instance = Mock.front_sensor_status_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_front_sensor_status);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.left_sensor_status_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_left_sensor_status);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.right_sensor_status_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_right_sensor_status);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.dust_sensor_status_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_dust_sensor_status);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.move_forward_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_move_forward);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.move_backward_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_move_backward);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.turn_left_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_turn_left);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.turn_right_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_turn_right);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.cleaner_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_cleaner);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.cleaner_power_up_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_cleaner_power_up);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
}

void mock_hw_interface_Init(void)
{
  mock_hw_interface_Destroy();
}

void mock_hw_interface_Destroy(void)
{
  CMock_Guts_MemFreeAll();
  memset(&Mock, 0, sizeof(Mock));
}

int front_sensor_status(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_front_sensor_status_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_front_sensor_status);
  cmock_call_instance = (CMOCK_front_sensor_status_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.front_sensor_status_CallInstance);
  Mock.front_sensor_status_CallInstance = CMock_Guts_MemNext(Mock.front_sensor_status_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void front_sensor_status_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, int cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_front_sensor_status_CALL_INSTANCE));
  CMOCK_front_sensor_status_CALL_INSTANCE* cmock_call_instance = (CMOCK_front_sensor_status_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.front_sensor_status_CallInstance = CMock_Guts_MemChain(Mock.front_sensor_status_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
}

int left_sensor_status(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_left_sensor_status_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_left_sensor_status);
  cmock_call_instance = (CMOCK_left_sensor_status_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.left_sensor_status_CallInstance);
  Mock.left_sensor_status_CallInstance = CMock_Guts_MemNext(Mock.left_sensor_status_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void left_sensor_status_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, int cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_left_sensor_status_CALL_INSTANCE));
  CMOCK_left_sensor_status_CALL_INSTANCE* cmock_call_instance = (CMOCK_left_sensor_status_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.left_sensor_status_CallInstance = CMock_Guts_MemChain(Mock.left_sensor_status_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
}

int right_sensor_status(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_right_sensor_status_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_right_sensor_status);
  cmock_call_instance = (CMOCK_right_sensor_status_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.right_sensor_status_CallInstance);
  Mock.right_sensor_status_CallInstance = CMock_Guts_MemNext(Mock.right_sensor_status_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void right_sensor_status_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, int cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_right_sensor_status_CALL_INSTANCE));
  CMOCK_right_sensor_status_CALL_INSTANCE* cmock_call_instance = (CMOCK_right_sensor_status_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.right_sensor_status_CallInstance = CMock_Guts_MemChain(Mock.right_sensor_status_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
}

int dust_sensor_status(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_dust_sensor_status_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_dust_sensor_status);
  cmock_call_instance = (CMOCK_dust_sensor_status_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.dust_sensor_status_CallInstance);
  Mock.dust_sensor_status_CallInstance = CMock_Guts_MemNext(Mock.dust_sensor_status_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void dust_sensor_status_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, int cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_dust_sensor_status_CALL_INSTANCE));
  CMOCK_dust_sensor_status_CALL_INSTANCE* cmock_call_instance = (CMOCK_dust_sensor_status_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.dust_sensor_status_CallInstance = CMock_Guts_MemChain(Mock.dust_sensor_status_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void move_forward(MotorStatus status)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_move_forward_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_move_forward);
  cmock_call_instance = (CMOCK_move_forward_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.move_forward_CallInstance);
  Mock.move_forward_CallInstance = CMock_Guts_MemNext(Mock.move_forward_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_move_forward,CMockString_status);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_status), (void*)(&status), sizeof(MotorStatus), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_move_forward(CMOCK_move_forward_CALL_INSTANCE* cmock_call_instance, MotorStatus status);
void CMockExpectParameters_move_forward(CMOCK_move_forward_CALL_INSTANCE* cmock_call_instance, MotorStatus status)
{
  memcpy((void*)(&cmock_call_instance->Expected_status), (void*)(&status),
         sizeof(MotorStatus[sizeof(status) == sizeof(MotorStatus) ? 1 : -1])); /* add MotorStatus to :treat_as_array if this causes an error */
}

void move_forward_CMockExpect(UNITY_LINE_TYPE cmock_line, MotorStatus status)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_move_forward_CALL_INSTANCE));
  CMOCK_move_forward_CALL_INSTANCE* cmock_call_instance = (CMOCK_move_forward_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.move_forward_CallInstance = CMock_Guts_MemChain(Mock.move_forward_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_move_forward(cmock_call_instance, status);
}

void move_backward(MotorStatus status)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_move_backward_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_move_backward);
  cmock_call_instance = (CMOCK_move_backward_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.move_backward_CallInstance);
  Mock.move_backward_CallInstance = CMock_Guts_MemNext(Mock.move_backward_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_move_backward,CMockString_status);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_status), (void*)(&status), sizeof(MotorStatus), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_move_backward(CMOCK_move_backward_CALL_INSTANCE* cmock_call_instance, MotorStatus status);
void CMockExpectParameters_move_backward(CMOCK_move_backward_CALL_INSTANCE* cmock_call_instance, MotorStatus status)
{
  memcpy((void*)(&cmock_call_instance->Expected_status), (void*)(&status),
         sizeof(MotorStatus[sizeof(status) == sizeof(MotorStatus) ? 1 : -1])); /* add MotorStatus to :treat_as_array if this causes an error */
}

void move_backward_CMockExpect(UNITY_LINE_TYPE cmock_line, MotorStatus status)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_move_backward_CALL_INSTANCE));
  CMOCK_move_backward_CALL_INSTANCE* cmock_call_instance = (CMOCK_move_backward_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.move_backward_CallInstance = CMock_Guts_MemChain(Mock.move_backward_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_move_backward(cmock_call_instance, status);
}

void turn_left(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_turn_left_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_turn_left);
  cmock_call_instance = (CMOCK_turn_left_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.turn_left_CallInstance);
  Mock.turn_left_CallInstance = CMock_Guts_MemNext(Mock.turn_left_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  UNITY_CLR_DETAILS();
}

void turn_left_CMockExpect(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_turn_left_CALL_INSTANCE));
  CMOCK_turn_left_CALL_INSTANCE* cmock_call_instance = (CMOCK_turn_left_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.turn_left_CallInstance = CMock_Guts_MemChain(Mock.turn_left_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
}

void turn_right(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_turn_right_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_turn_right);
  cmock_call_instance = (CMOCK_turn_right_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.turn_right_CallInstance);
  Mock.turn_right_CallInstance = CMock_Guts_MemNext(Mock.turn_right_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  UNITY_CLR_DETAILS();
}

void turn_right_CMockExpect(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_turn_right_CALL_INSTANCE));
  CMOCK_turn_right_CALL_INSTANCE* cmock_call_instance = (CMOCK_turn_right_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.turn_right_CallInstance = CMock_Guts_MemChain(Mock.turn_right_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
}

void cleaner(CleanerCommand command)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_cleaner_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_cleaner);
  cmock_call_instance = (CMOCK_cleaner_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.cleaner_CallInstance);
  Mock.cleaner_CallInstance = CMock_Guts_MemNext(Mock.cleaner_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_cleaner,CMockString_command);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_command), (void*)(&command), sizeof(CleanerCommand), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_cleaner(CMOCK_cleaner_CALL_INSTANCE* cmock_call_instance, CleanerCommand command);
void CMockExpectParameters_cleaner(CMOCK_cleaner_CALL_INSTANCE* cmock_call_instance, CleanerCommand command)
{
  memcpy((void*)(&cmock_call_instance->Expected_command), (void*)(&command),
         sizeof(CleanerCommand[sizeof(command) == sizeof(CleanerCommand) ? 1 : -1])); /* add CleanerCommand to :treat_as_array if this causes an error */
}

void cleaner_CMockExpect(UNITY_LINE_TYPE cmock_line, CleanerCommand command)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_cleaner_CALL_INSTANCE));
  CMOCK_cleaner_CALL_INSTANCE* cmock_call_instance = (CMOCK_cleaner_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.cleaner_CallInstance = CMock_Guts_MemChain(Mock.cleaner_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_cleaner(cmock_call_instance, command);
}

void cleaner_power_up(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_cleaner_power_up_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_cleaner_power_up);
  cmock_call_instance = (CMOCK_cleaner_power_up_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.cleaner_power_up_CallInstance);
  Mock.cleaner_power_up_CallInstance = CMock_Guts_MemNext(Mock.cleaner_power_up_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  UNITY_CLR_DETAILS();
}

void cleaner_power_up_CMockExpect(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_cleaner_power_up_CALL_INSTANCE));
  CMOCK_cleaner_power_up_CALL_INSTANCE* cmock_call_instance = (CMOCK_cleaner_power_up_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.cleaner_power_up_CallInstance = CMock_Guts_MemChain(Mock.cleaner_power_up_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
}

